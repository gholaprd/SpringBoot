Why Lambda Expression came in java

Enables functional programming: All new JVM based languages take advantage of the functional paradigm in their 
applications, but programmers forced to work with Object-Oriented Programming (OOPS) till lambda expressions came. 

Why Use Joda-Time?
The date/time API, before Java 8, presented multiple design problems.

Among the problems is the fact that the Date and SimpleDateFormatter classes aren't thread-safe. 
To address this issue, Joda-Time uses immutable classes for handling date and time.
The Date class doesn't represent an actual date, but instead,
 it specifies an instant in time, with millisecond precision. The year in a Date starts from 1900,
Joda-Time also offers support for eight calendar systems, 
while Java offers just 2: Gregorian – java.util.GregorianCalendar and Japanese – java.util.JapaneseImperialCalendar.

Dependancy lookup

when obj gets the req dependancies on its own called DL. If we go the containes and ask for an obj then it is DL.
Majority we are avoiding it.

DI
if some external component gives the required dependancies called DI

# Ref store in conatined and obj store in JVM.

DI is type of IOC

Weak Hashmap used in storing the value in container
Map<beanId,objRef>

FilePath* never used in WEB APP.

Spring IoC is the mechanism to achieve loose-coupling between Objects dependencies. To achieve loose coupling and dynamic binding of the objects at runtime, 
objects dependencies are injected by other assembler objects.

IOC is not DI.

@Componet scan scan the current package not all present in classpath.

@Component - conveying to the spring to create an obj of class.

Constructor injection depencies are mandatory & final but in SC optional
Taking filed as final of obj then we can say class is immutable. we can change the state of obj creation in CI but SI we can do it.

Autowired field level problem we can't solve and can't mock the obj.

one Obj created per conatiner same obj return from conatiner for that bean called Sigleton. Only one obj across your app.

Prototype- bean def is one but get new obj.
prototype obj not created until the someone requested. create on demand. lazy intialization. destory after usage.container will not held the obj
its like use n throw , intialization lifecycle but not destruction lifecycle for prototype.

1)Only one obj per bean def per container  				Mutliple obj per bean def per conatiner
2)obj gets created during conatiner intialization		obj get creates on demand
3)Every conatiner return same obj						return new obj
4)container hold the ref for singleton obj				not hold the ref
5)obj destoy once container destroy						destroy after usage as part of GC
6)all the lifecycle phase apply							since container not holding the ref so lifecycle phase not apply


Spring Boot

2.xx not support for java 7

What is the difference between @SpringBootApplication and @EnableAutoConfiguration annotation?
The @SpringBootApplication is a combination of three annotations @Configuration (used for Java-based configuration),
@ComponentScan (used for component scanning), and @EnableAutoConfiguration (used to enable auto-configuration in Spring Boot).
Btw, this annotation is available from Spring 1.2 onwards which means if you are running on lower Spring Boot version then you will still need to use 
the @Configuration, @CompnentScan, and @EnableAutoConfiguration if you need those features.
 before 1.2 and after we can use the @SpringBootApplication
@Configuration to enable Java-based configuration
@ComponentScan to enable component scanning.
@EnableAutoConfiguration to enable Spring Boot's auto-configuration feature.
@ComponentScan
This annotation enables component-scanning so that the web controller classes and other components you create will be automatically discovered and 
registered as beans in Spring's Application Context. All the@Controller classes you write are discovered by this annotation.


@Controller - specilization of @component use to configure the spring mvc controller classes and spring bean to IOC container.
Indicates that an annotated class is a "Controller" (e.g. a web controller).
it is in spring core jar /package
It is typically used in combination with annotated handler methods based on the {@link org.springframework.web.bind.annotation.RequestMapping}
 annotation.

@RestController
Spring RestController annotation is a convenience annotation that is itself annotated with @Controller and @ResponseBody. This annotation is applied to a 
class to mark it as a request handler.

Spring RestController annotation is used to create RESTful web services using Spring MVC. Spring RestController takes care 
of mapping request data to the 
defined request handler method. Once response body is generated from the handler method, it converts it to JSON or XML 
response.

Framework	Path segment	http query parameter
Jersey (JAX-RS)	@PathParam	@QueryParam
Spring RESTFul	@PathVariable	@RequestParam

@PathParam reads the value from a path part of the called URI. @QueryParam is used to read the values ​​from QueryParameters of a URI call. 
These are after? listed in a URI.

MICROSERVICES
==============
It it architechrul way to design our appl uniquely with small modules developed individually ,packaged indvidually and 
deployed ondividually ,in individiually process


Why Microservice
previously developing and deploying app eficien way in monolithic approach
developing individually but packaging dependently as single 	war

Whats are the drawbacks in monolithic aproach

Performance issue due to huge data (means in terms of War)
CICD not posssible (if there is bug in services then repackage all services)
Adopting new technology is not possible
Exception propogation not proper(If one services failed then all ur appl down)
code redeability not there.

What Is Spring Cloud?
Probably, the first microservices interview question that you may encounter. Spring Cloud in Microservices, 
is a system that provides integration with external systems.
features mentioned-below:
Discovery of service registration
Service to service calls
Routing
Circuit breakers and load balancing

Best design of MS
- Seprate build for each MS
- Seprate data store for each MS
- Deploy into containers

DDD(Domain driven Design)
Focus on Core domain logic
find the complex on modelof the domain 
constanly collabarate with  domain experts

Need of DDD
Maintaability
testablity
reduced compexity

Spring Cloud
spring Cloud in Microservices, is a system that provides integration with external systems.
features
Services discovery
service to service call
ckt breaker and load balancing
routing

Can you give a gist about Rest and Microservices?
REST
Though you can implement microservices in multiple ways, REST over HTTP is a way to implement Microservices. 
REST is also used in other applications such as web apps, API design, and MVC applications to serve business data.

Microservices
Microservices is an architecture wherein all the components of the system are put into individual components, 
which can be built, deployed, and scaled individually. There are certain principles and best practices of
 Microservices that help in building a resilient application

What is Bounded Context?
Bounded Context is a central pattern in Domain-Driven Design.

What are the challenges faced while using Microservices?

Microservices always rely on each other. Therefore, they need to communicate with each other.
DevOps is a must, because of the explosion of a number of processes in a production system. 
How to deploy multiple versions of single microservice and route calls appropriately?
How to aggregate logs/metrics across the services? 

Achieve zero down time during deployment?
One way of achieving this is blue/green deployment. In this approach, two versions of a single microservice are
 deployed at a time. But only one version is taking real requests. Once the newer version is tested to the required 
 satisfaction level, you can switch from older version to newer version.

You can run a smoke-test suite to verify that the functionality is running correctly in the newly deployed version
Blue-green deployment is a technique that reduces downtime and risk by running two identical production environments 
called Blue and Green. At any time, only one of the environments is live, with the live environment serving all 
production traffic. For this example, Blue is currently live and Green is idle.

As you prepare a new version of your software, deployment and the final stage of testing takes place in the 
environment that is not live: in this example, Green. Once you have deployed and fully tested the software in Green, 
you switch the router so all incoming requests now go to Green instead of Blue. Green is now live, and Blue is idle.

This technique can eliminate downtime due to application deployment. In addition, blue-green deployment reduces 
risk: if something unexpected happens with your new version on Green, you can immediately roll back to the last 
version by switching back to Blue.


Scaling up microservices??
One can scale the system by increasing the number of instances of service by bringing up more containers.
One can also shut down some containers when the requirement is less. That is, scale down.

12Factor app

Codebase
One codebase, multiple deploys. This means that we should only have one codebase for different versions of a 
microservices. Branches are ok, but different repositories are not.
Dependencies
Explicitly declare and isolate dependencie
Config
Store config in the environment. 
Backing services 
instead of hard coding url for another service in your RestTemplate, use Ribbon (with or without Eureka) to define the url: 
Release & Run 
Strictly separate build and run stages.
Processes 
Execute the app as one or more stateless processes.
Port Binding 
Export services via port binding. 
Concurrency 
Scale-out via the process model. 
Disposability 
The twelve-factor app’s processes are disposable, meaning they can be started or stopped at a moment’s notice.
Dev/Prod parity 
Keep development, staging, and production as similar as possible
Logs 
Treat logs as event streams, sending all logs only to stdout.
Admin processes 
Run admin/management tasks as one-off processes. 



End to End testing validates all the processes in the workflow to check if everything is working properly as expected

Why Would You Opt For Microservices Architecture?
Microservices can adapt easily to other frameworks or technologies.
Failure of a single process does not affect the entire system.
Provides support to big enterprises as well as small teams.
Can be deployed independently and in relatively less time.

Eureka knows as Netflix service discovery
Netflix provided internally uses of cloud

Register the services in Eureka server
cleint will not directly communicate with services it should like through  eureka server bcz the url should hardcoded 

Microservices are often integrated using a simple protocol like REST over HTTP. Other communication protocols can also be used for integration like AMQP,
 JMS, Kafka, etc.

The communication protocol can be broadly divided into two categories- synchronous communication and asynchronous communication.

Synchronous Communication
RestTemplate, WebClient, FeignClient can be used for synchronous communication between two microservices. Ideally, we should minimize the number of 
synchronous calls between microservices because networks are brittle and they introduce latency. Ribbon - a client-side load balancer can be used for
better utilization of resource on the top of RestTemplate. Hystrix circuit breaker can be used to handle partial failures gracefully without a 
cascading effect on the entire ecosystem. Distributed commits should be avoided at any cost, instead, we shall opt for eventual consistency using 
asynchronous communication.

Asynchronous Communication
In this type of communication, the client does not wait for a response, instead, it just sends the message to the message broker. 
AMQP (like RabbitMQ) or Kafka can be used for asynchronous communication across microservices to achieve eventual consistency.

You must use asynchronous communication while handling HTTP POST/PUT (anything that modifies the data) requests, using some reliable queue mechanism 
(RabbitMQ, AMQP, etc.) 
It's fine to use synchronous communication for Aggregation pattern at API Gateway Level. But this aggregation should not include any business logic other 
than aggregation. Data values must not be transformed at Aggregator, otherwise, it defeats the purpose of Bounded Context. In Asynchronous communication,
 events should be published into a Queue. Events contain data about the domain, it should not tell what to do (action) on this data. 
If microservice to microservice communication still requires synchronous communication for GET operation, then seriously reconsider the partitioning of 
your microservices for bounded context, and create some tasks in backlog/technical debt


There are certain advantages.

1.URLs are not hardcoded.

2.you don't have to write unit test cases for feign as there is no code to test however you have to write integration tests.

3.we can use Eureka Client ID instead of the URL.

4.Feign handled the actual code.

5.Feign integrates with Ribbon and Eureka Automatically.
What are the challenges you face while working Microservice Architectures?
Configuration Management: Maintaining the configurations for the components across the various environments becomes 
tough sometimes.
Debugging: Difficult to find out each and every service for an error. It is essential to maintain centralized 
logging and dashboards to debug problems.

singleton: Only one instance of the bean will be created for each container. This is the default scope for the spring beans. While using this scope, 
make sure spring bean doesn’t have shared instance variables otherwise it might lead to data inconsistency issues because it’s not thread-safe.

What is Bean wiring and @Autowired annotation?
The process of injection spring bean dependencies while initializing it called Spring Bean Wiring.

Does Spring Bean provide thread safety?
The default scope of Spring bean is singleton, so there will be only one instance per context. That means that all the having a class level variable 
that any thread can update will lead to inconsistent data. Hence in default mode spring beans are not thread-safe.

However, we can change spring bean scope to request, prototype or session to achieve thread-safety at the cost of performance. 
It’s a design decision and based on the project requirements.

What is a Controller in Spring MVC?
Just like MVC design pattern, Controller is the class that takes care of all the client requests and send them to the configured resources to handle it.
 In Spring MVC, org.springframework.web.servlet.DispatcherServlet is the front controller class that initializes the context based on the spring beans
  configurations.
  
  What is DispatcherServlet and ContextLoaderListener?
DispatcherServlet is the front controller in the Spring MVC application and it loads the spring bean configuration file and initialize all the beans that
 are configured. If annotations are enabled, it also scans the packages and configure any bean annotated with @Component, @Controller, 
 @Repository or @Service annotations.

ContextLoaderListener is the listener to start up and shut down Spring’s root WebApplicationContext. It’s important functions are to tie up the 
lifecycle of ApplicationContext to the lifecycle of the ServletContext and to automate the creation of ApplicationContext. We can use it to define 
shared beans that can be used across different spring contexts.

Can we have multiple Spring configuration files?
For Spring MVC applications, we can define multiple spring context configuration files through contextConfigLocation. This location string can consist 
of multiple locations separated by any number of commas and spaces. 

What is ContextLoaderListener?
ContextLoaderListener is the listener class used to load root context and define spring bean configurations that will be visible to all other contexts. 
It’s configured in web.xml file

How can we use Spring to create Restful Web Service returning JSON response?
By using jackson databing dependancy

Define Bean Wiring.
When beans are combined together within the Spring container, it’s called wiring or bean wiring. The Spring container needs to know what beans are
 needed and how the container should use dependency injection to tie the beans together, while wiring beans.
 
 What is an entity?
The entity is a group of states associated together in a single unit. An entity behaves as an object and becomes a major constituent of the 
object-oriented paradigm


What are the types of cascade supported by JPA?
Following is the list of cascade type: -

PERSIST: In this cascade operation, if the parent entity is persisted then all its related entity will also be persisted.
MERGE: In this cascade operation, if the parent entity is merged, then all its related entity will also be merged.
DETACH: In this cascade operation, if the parent entity is detached, then all its related entity will also be detached.
REFRESH: In this cascade operation, if the parent entity is refreshed, then all its related entity will also be refreshed.
REMOVE: In this cascade operation, if the parent entity is removed, then all its related entity will also be removed.
ALL In this case, all the above cascade operations can be applied to the entities related to the parent entity.

One-to-one mapping: The one-to-one mapping represents a single-valued association where an instance of one entity is associated with an instance of another
 entity. In this type of association, one instance of source entity can be mapped with at most one instance of the target entity.
One-To-Many mapping: The One-To-Many mapping comes into the category of collection-valued association where an entity is associated with a collection of 
other entities. In this type of association, the instance of one entity can be mapped with any number of instances of another entity.
Many-to-one mapping The Many-To-One mapping represents a single-valued association where a collection of entities can be associated with the similar 
entity. In the relational database, more than one row of an entity can refer to the same row of another entity.
Many-to-many mapping The Many-To-Many mapping represents a collection-valued association where any number of entities can be associated with a 
collection of other entities. In the relational database, more than one row of one entity can refer to more than one row of another entity.

What is the Java Persistence API?
The Java Persistence API (JPA) is the specification of Java that is used to persist data between Java object and relational database. 
JPA acts as a bridge between object-oriented domain models and relational database systems. As JPA is just a specification, it doesn't perform any
 operation by itself. It requires an implementation. Therefore, ORM tools like Hibernate, TopLink, and iBatis implements JPA
 
 What does the @Id annotation do?
The @Id annotation marks a field as the primary key for that particular table. This is a unique identifier for each entry in the table. 
This annotation is typically used with @GeneratedValue to automatically generate an unique id for each entry in the table.

What does the @Entity annotation do?
The @Entity annotation indicates a class represents a relational table in the database

Here comes the role of Spring data JPA, which sits right between application’s domain layer and JPA implementation like Hibernate. 
With it’s out-of-the-box features, many of the problems are solved and it gets easy to talk with any JPA implementation.

What features does Spring data JPA provides?
It provides built-in out of the box support for repositories, according to our Entity classes. This alone removes almost all the typical repository boilerplate code.
Query creation from method declaration. We can name methods in a specific format and it provides us the query implementation to fetch the data.
It has built-in pagination support.
Support for dynamic query execution.
Support for Type-Safe queries by QueryDSL.

AUTO: Hibernate selects the generation strategy based on the used dialect,
IDENTITY: Hibernate relies on an auto-incremented database column to generate the primary key,
SEQUENCE: Hibernate requests the primary key value from a database sequence,
TABLE: Hibernate uses a database table to simulate a sequence.

What are the possible states of entity bean?
Entity bean can have below possible state –

Transient: When ever we create a new object of Entity bean then we can say that is in Transient state,At that time any modification in the object state 
does not effect on database.
Persistent: When ever the Object of entity bean associated with session we can say that is in persistent state, if any change in the object state , 
then that modification effects in database.
Detached :When ever the object is removed from session then it enters in to detached state.Any modification on detached state object , does not effect 
in database.

Can you make entity class as final?
You can make an Hibernate Entity class final, but that’s not a good practice.
Generally, persistence providers make proxies of objects using some library like CGLIB or javassist. 

What is the difference between get() and load() and when to use what ?
If no row with the given identifier value exists in the database, get() returns null. The load() method throws an ObjectNotFoundException.

Here evict() is used to remove a particular object from cache associated with session, and clear() method is used to remove all cached objects 
associated with session. 

SPRING BOOT
===============

The "spring-boot-starter-parent" is a special starter that provides useful Maven defaults i.e it adds all the required jars and other things automatically. 
It also provides a dependency-management section so that you can omit version tags for dependencies you are using in pom.

What is a Spring Boot Actuator?

Spring Boot Actuator allows you to monitor and manage your application when you want to push it for the production. It helps you to control your 
application by using HTTP endpoints.

What is a shutdown in the actuator?

A shutdown is an endpoint that helps application to be shut down properly. This feature is not enabled by default.

However, you can use it by setting command: management.endpoint.shutdown.enabled=true in your

What is Spring Boot? Why should you use it?
Spring Boot is another Java framework from Sring umbrella which aims to simplify the use of Spring Framework for Java development. 
It removes most of the pain associated with dealing with Spring e.g. a lot of configuration and dependencies and a lot of manual setups.

Why should you use it? Well, Spring Boot not only provides a lot of convenience by auto-configuration a lot of things for you but also 
improves the productivity because it lets you focus only on writing your business logic.

For example, you don't need to setup a Tomcat server to run your web application. You can just write code and run it as Java application 
because it comes with an embedded Tomcat server. You can also create a JAR file or WAR file for deployment based on your convenience.

Features
=======
Starter dependency
This feature aggregates common dependencies together. For example, if you want to develop Spring MVC based RESTful services then instead of including
 Spring MVC JAR and Jackson JAR file into classpath you can just specify spring-boot-web-starter and it will automatically download both those JAR files. 
 Spring Boot comes with many such starter dependencies to improve productivity.

Spring Actuator
This feature provides a lot of insights of a running Spring boot application. For example, you can use Actuator to find out which beans are created 
in Spring's application context and which request path are mapped to controllers.

It provides several endpoints e.g. a REST endpoint to retrieve this kind of information over the web. It also provides a lot of insight and 
metrics about application health e.g. CPU and memory usage, number of threads etc.

/showdown endpoint you can kill a Spring Boot application.

What is the difference between an embedded container and a WAR?
The main difference between an embedded container and a WAR file is that you can Spring Boot application as a JAR from the command prompt without 
setting up a web server. But to run a WAR file, you need to first set up a web server like Tomcat which has Servlet container and then you need to 
deploy WAR there.

@RequestMapping
This annotation is used to provide the routing information and tells to Spring that any HTTP request must be mapped to the respective method.

What do you understand by auto-configuration in Spring Boot and how to disable the  auto-configuration?
Auto-configuration is used to automatically configure the required configuration for the application. For example, if you have a data source bean present
 in the classpath of the application, then it automatically configures the JDBC template. With the help of auto-configuration, you can create a
  Java application in an easy way, as it automatically configures the required beans, controllers, etc. 

To disable the auto-configuration property, you have to exclude attribute of @EnableAutoConfiguration, in the scenario where you do not want it to be 
applied.

1
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
If the class is not on the classpath, then to exclude the auto-configuration, you have to mention the following code:

1
@EnableAutoConfiguration(excludeName={Sample.class})

if you want to build a WAR file, then you will mention

<packaging>war</packaging>

The name of the default H2 database is testdb.  

SPRING DATA JPA
What is the Java Persistence API?
PA acts as a bridge between object-oriented domain models and relational database systems. 
As JPA is just a specification, it doesn't perform any operation by itself. It requires an implementation. 
Therefore, ORM tools like Hibernate, TopLink, and iBatis implements JPA.

What is Spring Data JPA?
Spring Data JPA is one of Spring Data module which provides predefined repository methods to perform CRUD operation.
 Using Spring Data JPA we define the repository interface and query methods(query creation from method names) to 
 access the data from the database.
 
 How to enable Spring Data JPA features.
First, we need to define some configuration class let’s say JpaConfig.java and then we need to use
 @EnableJpaRepositories annotation with that class. 
 
 The CrudRepository’s save() method is used to perform save as well as update operation both. 
 The implementation has been given in SimpleJpaRepository.java, where persist() and merge() is getting called.
 
 The CrudRepository saveAll() method used to save multiple entities and internally annotated with @Transactional 
 annotation. It internally uses save() method 
 
 The findById() method will return null if the record doesn’t exist in the database.available in CrudRepository interface.
 The getOne() method throw EntityNotFoundException if the record doesn’t exist in the database.JpaRepositpry interface.
 
 The delete() method internally uses EntityManager’s remove() method as below.
 The first one i.e delete() internally uses remove() method. Before call remove() method it calls contains()/merge() method.
 deleteInBatch() prepares the query and collect some other information and directly calls the executeUpdate() method.
 
 deleteAll() internally use delete() method only.
 deleteAllInBatch(), EntityManger createQuery() method will preapare the query and it directly calls executeUpdate() method.
 
 What will happen when we define wrong Query Methods in Spring Data JPA?
 will give error at the server up time UnsatisfiedDependencyException
 
 What is the Difference Between JPA and Hibernate?
As we know that JPA is just a specification, meaning there is no implementation. You can annotate your classes as much as you would like with JPA 
annotations, however, without an implementation, nothing will happen. Think of JPA as the guidelines that must be followed or an interface, 
while Hibernate's JPA implementation is code that meets the API as defined by the JPA specification and provides the under the hood functionality.

A JPA entity class is a POJO (Plain Old Java Object) class, i.e. an ordinary Java class that is marked (annotated) as having the ability to 
represent objects in the database. Conceptually this is similar to serializable classes, which are marked as having the ability to be serialized

What are the JPA Cascade Types?
JPA allows you to propagate the state transition from a parent entity to a child. For this purpose, the JPA javax.persistence.
CascadeType defines various cascade types:
ALL - cascades all entity state transitions
PERSIST - cascades the entity persist operation.
MERGE - cascades the entity merge operation.
REMOVE - cascades the entity remove operation.
REFRESH - cascades the entity refresh operation.

 What is Entity?
Entity is a lightweight persistent domain object. The main program entity is the entity class, which can also use additional classes that can 
be used as auxiliary classes or to maintain state of the entity.

6. Can the Entity class inherit from non-Entity classes?
Can.

7. Can an Entity class inherit from other Entity classes?
The same can.


8. Can a non-Entity class inherit from an Entity class?
And this is also permissible.

9. Can Entity be an abstract class?
Perhaps, at the same time, it retains all the properties of the Entity, except that it cannot be directly initialized.
DETACH - cascades the entity detach operation.
 
 
  What JPA requirements for Entity classes can you list (at least six requirements)?
1) Entity class must be annotated with Entity or described in the XML configuration file JPA,

2) Entity class must contain a public or protected constructor with no arguments (it can also have constructors with arguments),

3) Entity class must be a top-level class (top -level class),

4) Entity class cannot be enum or interface,

5) Entity class cannot be final class,

6) Entity class cannot contain final fields or methods if they participate in mapping (persistent final methods or persistent final instance variables),

7) If an Entity class object is passed by value as a separate object (detached object), for example through a remote interface 
(through a remote interface), it must also implement a Serializable interface,

8) The Entity class fields should be directly accessible only to the methods of the Entity class and should not be directly accessible to other 
classes using this entity. Such classes should refer only to methods (getter / setter methods or other business logic methods in the Entity class),

9) The Enity class must contain a primary key, that is, an attribute or group of attributes that uniquely defines the record of this Enity class in
 the database.
 
 
 #RESTSERVICE#
 =============
 
 RESTful web services use web protocol i.e. HTTP protocol method. They have the feature like scalability, maintainability, help multiple application 
 communication built on various programming languages, etc.
 The important aspects of this implementation include:

Resources
Request Headers
Request Body
Response Body
Status codes

Name the protocol which is used by RESTful web services.

Answer: RESTful web services use a famous web protocol i.e. HTTP protocol. This serves as a medium of data communication between client and server. 
HTTP standard methods are used to access resources in RESTful web service architecture.


What are the core components of the HTTP request and HTTP response?

Answer: The core components under HTTP Request are:

Verb: Includes methods like GET, PUT, POST, etc.
Uniform Resource Identifier for identifying the resources available on the server.
HTTP Version for specifying the HTTP version.
HTTP Request header for containing the information about the data.
HTTP Request body that contains the representation of the resources in use.
The core components under HTTP Response are:

Request Code: This contains various codes that determine the status of the server response.
HTTP Version for specifying the HTTP version.
HTTP Response header for containing the information about the data.
HTTP Response body that contains the representation of the resources in use.

What is a ‘Resource’?

Answer: Just like the ‘Object’ instance, we have learned in Object Orient Programming Language, in the same way, ‘Resource’ is defined as an object of a 
type which can be an image, HTML file, text data, and any type of dynamic data. There are varieties of representation formats available in order to
 represent a resource.

Some most common Resources are enlisted below:

JSON
YAML
XML
HTML

What is Payload?

Answer: The request data which is present in the body part of every HTTP message is referred to as ‘Payload’.  In Restful web service, the payload can 
only be passed to the recipient through the POST method.

What is the difference between the PUT method and the POST method?

Answer: The major difference between the PUT and POST method is that the result generated with the PUT method is always the same no matter how many times 
the operation is performed. On the other hand, the result generated by POST operation is always different every time.